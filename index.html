<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Buszuteilung KJF Emsland</title> <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.23/jspdf.plugin.autotable.min.js"></script>
    <style>
        /* Globale Schriftart */
        body { font-family: 'Inter', sans-serif; }

        /* Styling für Eingabegruppen */
        .input-row { display: flex; align-items: center; background-color: #f3f4f6; padding: 0.5rem 1rem 0.5rem 0.5rem; border-radius: 0.375rem; gap: 0.5rem; }
        .input-row label { flex-shrink: 0; font-size: 0.875rem; font-weight: 500; color: #374151; text-align: right; min-width: 60px; }
        .input-row input[type="text"] { flex-grow: 1; min-width: 150px; }
        .input-row input[type="number"] { width: 80px; flex-shrink: 0; }
        .input-row input { box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); border: 1px solid #d1d5db; border-radius: 0.375rem; padding: 0.375rem 0.5rem; font-size: 0.875rem; background-color: #fff; color: #111827; }
        .input-row input:focus { outline: 2px solid transparent; outline-offset: 2px; border-color: #4f46e5; box-shadow: 0 0 0 2px #a5b4fc; }
        .remove-btn { cursor: pointer; font-weight: bold; margin-left: 0.25rem; padding: 0.25rem; flex-shrink: 0; line-height: 1; color: #ef4444; }
        .remove-btn:hover { color: #dc2626; }

        /* Styling für Buttons (Basis) */
        .action-button { font-weight: 600; padding: 0.5rem 1rem; border-radius: 0.375rem; font-size: 0.875rem; transition: background-color 0.3s ease; color: white; cursor: pointer; border: none; }
        .action-button:disabled { opacity: 0.5; cursor: not-allowed; }

        /* Basis-Styling für Ergebnisboxen etc. */
        .result-box { border: 1px solid #ccc; padding: 15px; margin-bottom: 15px; border-radius: 8px; background-color: #f9f9f9; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .result-box h4 { margin-top: 0; color: #333; border-bottom: 1px solid #eee; padding-bottom: 5px; margin-bottom: 10px; }
        .result-box ul { list-style-type: none; padding-left: 0; margin-bottom: 10px; }
        .result-box li { background-color: #e7f3ff; padding: 5px 10px; margin-bottom: 5px; border-radius: 4px; font-size: 0.9em; word-break: break-word; }
        .result-box li.split-part { background-color: #fffbeb; border-left: 3px solid #facc15; }
        .result-box p { font-weight: bold; color: #555; font-size: 0.9em; }

        /* Styling für aufgeteilte Gruppen Details */
        .split-details-box { border-color: #fdba74; background-color: #fffbeb; }
        .split-details-box h4 { color: #a16207; border-color: #fed7aa; }
        .split-details-box ul { font-size: 0.9em; }
        .split-details-box li { background-color: #fed7aa; margin-bottom: 8px; padding: 8px; border-radius: 4px; }
        .split-details-box li ul { list-style-type: disc; padding-left: 20px; margin-top: 5px; }
        .split-details-box li ul li { background-color: transparent; padding: 2px 0; margin-bottom: 2px; font-size: 0.95em; }

        /* Styling für nicht zugeordnete Gruppen */
        .unassigned-box { border-color: #f5c6cb; background-color: #f8d7da; }
        .unassigned-box h4 { color: #721c24; border-color: #f5c6cb; }
        .unassigned-box li { background-color: #f5c6cb; }

        /* Styling für Datei-Upload */
        .file-input-label { display: block; margin-bottom: 5px; font-size: 0.9em; color: #555; }
        .file-input { display: block; width: 100%; padding: 8px; margin-bottom: 5px; font-size: 0.9em; border: 1px solid #ccc; border-radius: 4px; background-color: #fff; }
        .template-download-link { font-size: 0.8rem; color: #3b82f6; text-decoration: underline; cursor: pointer; }
        .template-download-link:hover { color: #2563eb; }

        /* Styling für Zusammenfassungsbox */
        .summary-box { padding: 1rem; margin-bottom: 1.5rem; border-radius: 0.5rem; border: 1px solid; }
        .summary-box p { margin-bottom: 0.5rem; font-size: 0.95em; }
        .summary-box strong { font-weight: 600; }
        .summary-ok { border-color: #a7f3d0; background-color: #d1fae5; color: #065f46; }
        .summary-warning { border-color: #fecaca; background-color: #fee2e2; color: #991b1b; }

        /* Styling für Puffer-Eingabe */
        #reservedSeatsContainer label { font-weight: 500; }
        #reservedSeats { width: 100px; margin-left: 10px; }

        /* Styling für manuelle Anpassung */
        #manualAdjustContainer { background-color: #f0f9ff; border: 1px solid #bfdbfe; padding: 1rem; border-radius: 0.5rem; margin-top: 1rem; }
        #manualAdjustMode label { margin-right: 1rem; font-size: 0.9em; cursor: pointer; }
        #manualAdjustFields > div { margin-bottom: 0.75rem; } /* Abstand für Selects/Buttons */
        #manualAdjustFields label { display: block; margin-bottom: 0.25rem; font-size: 0.875rem; font-weight: 500; color: #1e40af; }
        #manualAdjustFields select, #manualAdjustButton { width: 100%; padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 0.375rem; font-size: 0.875rem; }

        /* Styling für Nachrichtenanzeige */
        #messageArea { position: sticky; top: 0; left: 0; right: 0; z-index: 100; padding: 0.75rem 1rem; margin-bottom: 1rem; border-radius: 0.375rem; font-weight: 500; display: none; /* Standardmäßig ausgeblendet */ }
        .message-error { background-color: #fee2e2; color: #b91c1c; border: 1px solid #fecaca; }
        .message-success { background-color: #dcfce7; color: #166534; border: 1px solid #bbf7d0; }
        .message-info { background-color: #e0f2fe; color: #075985; border: 1px solid #bae6fd; }
        .message-warning { background-color: #fef3c7; color: #92400e; border: 1px solid #fde68a; }
        #messageArea button { float: right; background: none; border: none; font-size: 1.2rem; line-height: 1; cursor: pointer; color: inherit; opacity: 0.7; }
        #messageArea button:hover { opacity: 1; }

        /* Responsive Anpassungen für manuelle Anpassung */
        @media (min-width: 768px) { /* md: */
            #manualAdjustFields { display: flex; align-items: flex-end; gap: 1rem; }
            #manualAdjustFields > div { flex-grow: 1; margin-bottom: 0; }
            #manualAdjustFields label { margin-bottom: 0.5rem; }
            #manualAdjustFields select, #manualAdjustButton { width: auto; }
            #manualAdjustButton { flex-shrink: 0; }
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-900">
    <div class="max-w-4xl mx-auto bg-white p-6 rounded-lg shadow-md relative">
        <div id="messageArea">
            <span id="messageText"></span>
            <button onclick="hideMessage()">&times;</button>
        </div>

        <h1 class="text-2xl font-bold mb-6 text-center text-gray-700">Buszuteilung</h1>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-8 mb-6">
             <div>
                <h2 class="text-xl font-semibold mb-3 text-gray-600">Jugendgruppen</h2>
                <div class="mb-4 p-3 bg-blue-50 rounded-lg border border-blue-200">
                    <label for="gruppenCsvInput" class="file-input-label font-medium text-blue-700">Gruppen aus CSV importieren:</label>
                    <input type="file" id="gruppenCsvInput" accept=".csv" onchange="handleGroupCSVImport(event)" class="file-input">
                    <p class="text-xs text-gray-500 mt-1">Format: Name;Teilnehmerzahl (pro Zeile). Kopfzeile wird ignoriert. <strong class="text-red-600">Wichtig:</strong> Datei sollte als UTF-8 gespeichert sein.</p>
                    <a onclick="downloadGroupTemplate()" class="template-download-link">Vorlage herunterladen (gruppen_vorlage.csv)</a>
                </div>
                <div id="gruppenContainer" class="space-y-2 mb-3"></div>
                <div class="flex justify-between items-center mt-3">
                    <button onclick="addGruppeInput()" class="action-button bg-blue-500 hover:bg-blue-600">
                        + Gruppe hinzufügen
                    </button>
                    <button onclick="exportGruppenToCSV()" class="action-button bg-gray-500 hover:bg-gray-600">
                        Gruppen als CSV speichern
                    </button>
                </div>
            </div>
            <div>
                <h2 class="text-xl font-semibold mb-3 text-gray-600">Reisebusse</h2>
                 <div class="mb-4 p-3 bg-green-50 rounded-lg border border-green-200">
                    <label for="busCsvInput" class="file-input-label font-medium text-green-700">Busse aus CSV importieren:</label>
                    <input type="file" id="busCsvInput" accept=".csv" onchange="handleBusCSVImport(event)" class="file-input">
                     <p class="text-xs text-gray-500 mt-1">Format: Kennzeichnung;Sitzplätze (pro Zeile). Kopfzeile wird ignoriert. <strong class="text-red-600">Wichtig:</strong> Datei sollte als UTF-8 gespeichert sein.</p>
                     <a onclick="downloadBusTemplate()" class="template-download-link">Vorlage herunterladen (busse_vorlage.csv)</a>
                </div>
                <div id="busContainer" class="space-y-2 mb-3"></div>
                 <div class="flex justify-between items-center mt-3">
                    <button onclick="addBusInput()" class="action-button bg-green-500 hover:bg-green-600">
                        + Bus hinzufügen
                    </button>
                     <button onclick="exportBusseToCSV()" class="action-button bg-gray-500 hover:bg-gray-600">
                        Busse als CSV speichern
                    </button>
                </div>
            </div>
        </div>

        <div id="reservedSeatsContainer" class="mb-6 p-4 bg-yellow-50 border border-yellow-200 rounded-lg flex items-center">
            <label for="reservedSeats" class="text-sm text-yellow-800">Anzahl Plätze, die pro Bus frei bleiben sollen (Puffer):</label>
            <input type="number" id="reservedSeats" value="0" min="0" class="input-row input ml-2 shadow-sm focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm border-gray-300 rounded-md p-1.5">
        </div>

        <div class="text-center mb-6">
            <button onclick="calculateAssignment()" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-6 rounded-lg text-lg transition duration-300">
                Zuteilung berechnen
            </button>
        </div>

        <div id="zusammenfassungBereich" class="mb-6"></div>

        <div id="ergebnisBereich">
             <div id="actionButtonsContainer" class="flex flex-wrap justify-end gap-2 mb-4" style="display: none;">
                 <button id="toggleManualAdjustBtn" onclick="toggleManualAdjustUI()" class="action-button bg-indigo-500 hover:bg-indigo-600">
                     Manuelle Anpassung
                 </button>
                 <button id="pdfDownloadBtn" onclick="downloadResultsAsPDF()" class="action-button bg-red-500 hover:bg-red-600">
                     Ergebnis als PDF
                 </button>
            </div>
             <div id="manualAdjustContainer" style="display: none;">
                 <div id="manualAdjustMode" class="mb-4">
                     <span class="text-sm font-medium text-gray-700 mr-4">Aktion:</span>
                     <label>
                         <input type="radio" name="manualAdjustMode" value="move" checked onchange="updateManualAdjustUI()"> Verschieben
                     </label>
                     <label>
                         <input type="radio" name="manualAdjustMode" value="swap" onchange="updateManualAdjustUI()"> Tauschen
                     </label>
                 </div>
                 <div id="manualAdjustFields">
                     <div id="group1SelectContainer">
                         <label for="groupToMoveSelect">Gruppe 1:</label>
                         <select id="groupToMoveSelect"></select>
                     </div>
                     <div id="targetBusSelectContainer">
                         <label for="targetBusSelect">Ziel-Bus:</label>
                         <select id="targetBusSelect"></select>
                     </div>
                      <div id="group2SelectContainer" style="display: none;">
                         <label for="groupToSwapSelect">Gruppe 2:</label>
                         <select id="groupToSwapSelect"></select>
                     </div>
                     <button id="manualAdjustButton" onclick="handleManualAdjustment()" class="action-button bg-teal-500 hover:bg-teal-600">
                         Gruppe verschieben
                     </button>
                 </div>
                 <p class="text-xs text-gray-500 mt-2">Hinweis: Es können nur ganze Gruppen verschoben/getauscht werden.</p>
             </div>
            <h2 id="ergebnisTitel" class="text-xl font-semibold mb-3 text-gray-600 border-t border-gray-200 pt-4" style="display: none;">Ergebnis der Zuteilung</h2>
            <div id="ergebnisOutput" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4"></div>
            <div id="aufgeteiltDetailsOutput" class="mt-4"></div>
            <div id="nichtZugeordnetOutput" class="mt-4"></div>
            <div id="erfolgMeldungOutput" class="mt-4"></div>
        </div>
    </div>

    <script>
        let gruppenIdCounter = 0;
        let busIdCounter = 0;
        window.latestBusData = null;
        window.latestGroupData = null;
        window.latestSummaryData = null;
        const MAX_RETRIES = 10; // Konstante für maximale Wiederholungsversuche

        // --- Nachrichtenanzeige Funktionen (unverändert) ---
        function showMessage(message, type = 'info') { /* ... */
            const messageArea = document.getElementById('messageArea'); const messageText = document.getElementById('messageText');
            if (!messageArea || !messageText) return;
            messageText.innerHTML = message.replace(/\n/g, '<br>'); // Ersetze Newlines mit <br> für HTML
            messageArea.className = 'message-' + type;
            messageArea.style.display = 'block';
            messageArea.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
        function hideMessage() { /* ... */
            const messageArea = document.getElementById('messageArea'); if (messageArea) { messageArea.style.display = 'none';}
        }

        // --- Eingabe- und Hilfsfunktionen (unverändert) ---
        function addGruppeInput(name = '', size = '') { /* ... */
             gruppenIdCounter++; const container = document.getElementById('gruppenContainer'); const div = document.createElement('div'); div.id = `gruppe-${gruppenIdCounter}`; div.classList.add('input-row', 'bg-gray-100'); div.innerHTML = `<label for="gruppeName-${gruppenIdCounter}" class="text-gray-700">Name:</label><input type="text" id="gruppeName-${gruppenIdCounter}" value="${name}" placeholder="Gruppenname" class="gruppeNameInput border-gray-300 focus:border-indigo-500 focus:ring-indigo-500"><label for="gruppeSize-${gruppenIdCounter}" class="text-gray-700">Teiln.:</label><input type="number" id="gruppeSize-${gruppenIdCounter}" value="${size}" placeholder="Anz." class="gruppeSizeInput border-gray-300 focus:border-indigo-500 focus:ring-indigo-500" min="1"><span class="remove-btn text-red-500 hover:text-red-600" onclick="removeElement('gruppe-${gruppenIdCounter}')" title="Gruppe entfernen">X</span>`; container.appendChild(div);
        }
        function addBusInput(name = '', capacity = '') { /* ... */
             busIdCounter++; const container = document.getElementById('busContainer'); const div = document.createElement('div'); div.id = `bus-${busIdCounter}`; div.classList.add('input-row', 'bg-gray-100'); div.innerHTML = `<label for="busName-${busIdCounter}" class="text-gray-700">Kennz.:</label><input type="text" id="busName-${busIdCounter}" value="${name}" placeholder="Bus Kennzeichnung" class="busNameInput border-gray-300 focus:border-indigo-500 focus:ring-indigo-500"><label for="busCapacity-${busIdCounter}" class="text-gray-700">Plätze:</label><input type="number" id="busCapacity-${busIdCounter}" value="${capacity}" placeholder="Kap." class="busCapacityInput border-gray-300 focus:border-indigo-500 focus:ring-indigo-500" min="1"><span class="remove-btn text-red-500 hover:text-red-600" onclick="removeElement('bus-${busIdCounter}')" title="Bus entfernen">X</span>`; container.appendChild(div);
        }
        function removeElement(elementId) { /* ... */
             const element = document.getElementById(elementId); if (element) { element.remove(); hideMessage(); }
        }

        // --- CSV Import Funktionen (unverändert) ---
        function handleGroupCSVImport(event) { /* ... */
             const file = event.target.files[0]; if (!file) return; hideMessage();
            if (file.type !== 'text/csv' && !file.name.toLowerCase().endsWith('.csv')) { showMessage('Bitte wählen Sie eine gültige CSV-Datei aus.', 'error'); event.target.value = ''; return; }
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const text = e.target.result; const container = document.getElementById('gruppenContainer'); container.innerHTML = ''; gruppenIdCounter = 0;
                    const lines = text.split(/[\r\n]+/); let importErrors = []; let importedCount = 0; let skipFirstLine = false;
                    if (lines.length > 0 && lines[0].trim()) { const firstLineColumns = lines[0].trim().split(';'); if (firstLineColumns.length >= 2) { const firstLineSecondColInt = parseInt(firstLineColumns[1].trim()); if (isNaN(firstLineSecondColInt) || firstLineSecondColInt <= 0) { skipFirstLine = true; } } }
                    lines.forEach((line, index) => {
                        if (index === 0 && skipFirstLine) return;
                        const lineNumber = index + 1; const trimmedLine = line.trim(); if (trimmedLine === '') return;
                        const columns = trimmedLine.split(';');
                        if (columns.length >= 2) {
                            let name = columns[0].trim(); if (name.startsWith('"') && name.endsWith('"')) { name = name.substring(1, name.length - 1).replace(/""/g, '"'); }
                            const sizeString = columns[1].trim(); const size = parseInt(sizeString);
                            if (name && !isNaN(size) && size > 0) { addGruppeInput(name, size); importedCount++; }
                            else { let errorReason = "Unbekannter Fehler"; if (!name) errorReason = "Name fehlt"; else if (isNaN(size)) errorReason = `Teilnehmerzahl "${sizeString}" ist keine Zahl`; else if (size <= 0) errorReason = `Teilnehmerzahl "${size}" muss größer 0 sein`; importErrors.push(`Zeile ${lineNumber}: Ungültige Daten (${errorReason}) - Inhalt: "${trimmedLine}"`); }
                        } else { importErrors.push(`Zeile ${lineNumber}: Zu wenige Spalten (erwartet: Name;Teilnehmerzahl) - Inhalt: "${trimmedLine}"`); }
                    });
                    if (importErrors.length > 0) { const errorMessages = importErrors.map(msg => `- ${msg}`).join('\n'); const fullMessage = `Fehler beim Import der Gruppen-CSV (${importErrors.length} Fehler):\n${errorMessages}\n\nGültige Zeilen (${importedCount}) wurden dennoch importiert. Bitte prüfen Sie die CSV-Datei.`; showMessage(fullMessage, 'warning'); }
                    else if (importedCount > 0) { showMessage(`${importedCount} Gruppen erfolgreich importiert.`, 'success'); }
                    else if (!skipFirstLine && lines.filter(l => l.trim()).length === 0) { showMessage('Die CSV-Datei ist leer oder enthält nur leere Zeilen.', 'info'); }
                    else if (skipFirstLine && lines.filter(l => l.trim()).length <= 1) { showMessage('Die CSV-Datei enthält nur eine Kopfzeile oder ist ansonsten leer.', 'info'); }
                } catch (error) { console.error("Fehler beim Verarbeiten der Gruppen-CSV:", error); showMessage(`Ein unerwarteter Fehler ist beim Verarbeiten der Datei aufgetreten: ${error.message}`, 'error'); }
                finally { event.target.value = ''; }
            };
            reader.onerror = function(e) { showMessage('Fehler beim Lesen der Datei.', 'error'); event.target.value = ''; }; reader.readAsText(file, "UTF-8");
        }
        function handleBusCSVImport(event) { /* ... */
            const file = event.target.files[0]; if (!file) return; hideMessage();
            if (file.type !== 'text/csv' && !file.name.toLowerCase().endsWith('.csv')) { showMessage('Bitte wählen Sie eine gültige CSV-Datei aus.', 'error'); event.target.value = ''; return; }
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const text = e.target.result; const container = document.getElementById('busContainer'); container.innerHTML = ''; busIdCounter = 0;
                    const lines = text.split(/[\r\n]+/); let importErrors = []; let importedCount = 0; let skipFirstLine = false;
                     if (lines.length > 0 && lines[0].trim()) { const firstLineColumns = lines[0].trim().split(';'); if (firstLineColumns.length >= 2) { const firstLineSecondColInt = parseInt(firstLineColumns[1].trim()); if (isNaN(firstLineSecondColInt) || firstLineSecondColInt <= 0) { skipFirstLine = true; } } }
                    lines.forEach((line, index) => {
                         if (index === 0 && skipFirstLine) return;
                        const lineNumber = index + 1; const trimmedLine = line.trim(); if (trimmedLine === '') return;
                        const columns = trimmedLine.split(';');
                        if (columns.length >= 2) {
                            let name = columns[0].trim(); if (name.startsWith('"') && name.endsWith('"')) { name = name.substring(1, name.length - 1).replace(/""/g, '"'); }
                            const capacityString = columns[1].trim(); const capacity = parseInt(capacityString);
                            if (name && !isNaN(capacity) && capacity > 0) { addBusInput(name, capacity); importedCount++; }
                            else { let errorReason = "Unbekannter Fehler"; if (!name) errorReason = "Kennzeichnung fehlt"; else if (isNaN(capacity)) errorReason = `Kapazität "${capacityString}" ist keine Zahl`; else if (capacity <= 0) errorReason = `Kapazität "${capacity}" muss größer 0 sein`; importErrors.push(`Zeile ${lineNumber}: Ungültige Daten (${errorReason}) - Inhalt: "${trimmedLine}"`); }
                        } else { importErrors.push(`Zeile ${lineNumber}: Zu wenige Spalten (erwartet: Kennzeichnung;Sitzplätze) - Inhalt: "${trimmedLine}"`); }
                    });
                     if (importErrors.length > 0) { const errorMessages = importErrors.map(msg => `- ${msg}`).join('\n'); const fullMessage = `Fehler beim Import der Bus-CSV (${importErrors.length} Fehler):\n${errorMessages}\n\nGültige Zeilen (${importedCount}) wurden dennoch importiert. Bitte prüfen Sie die CSV-Datei.`; showMessage(fullMessage, 'warning'); }
                     else if (importedCount > 0) { showMessage(`${importedCount} Busse erfolgreich importiert.`, 'success'); }
                     else if (!skipFirstLine && lines.filter(l => l.trim()).length === 0) { showMessage('Die Bus-CSV-Datei ist leer oder enthält nur leere Zeilen.', 'info'); }
                     else if (skipFirstLine && lines.filter(l => l.trim()).length <= 1) { showMessage('Die Bus-CSV-Datei enthält nur eine Kopfzeile oder ist ansonsten leer.', 'info'); }
                } catch (error) { console.error("Fehler beim Verarbeiten der Bus-CSV:", error); showMessage(`Ein unerwarteter Fehler ist beim Verarbeiten der Datei aufgetreten: ${error.message}`, 'error'); }
                finally { event.target.value = ''; }
            };
            reader.onerror = function(e) { showMessage('Fehler beim Lesen der Datei.', 'error'); event.target.value = ''; }; reader.readAsText(file, "UTF-8");
        }

        // --- Download Funktionen (Template und Export) (unverändert) ---
        function downloadFile(filename, content, mimeType = 'text/csv;charset=utf-8;') { /* ... */
             const blob = new Blob(["\uFEFF" + content], { type: mimeType }); const link = document.createElement("a");
            if (link.download !== undefined) { const url = URL.createObjectURL(blob); link.setAttribute("href", url); link.setAttribute("download", filename); link.style.visibility = 'hidden'; document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(url); /* showMessage(`Datei "${filename}" wird heruntergeladen.`, 'info'); */ } // Info-Msg hier evtl. störend
            else { showMessage("Ihr Browser unterstützt das direkte Herunterladen von Dateien nicht.", 'warning'); }
        }
        function downloadGroupTemplate() { /* ... */
             const csvContent = "Gruppenname;Teilnehmerzahl\nBeispielgruppe ÄÖÜ;25\nBeispielgruppe B 🎉;18\n"; downloadFile("gruppen_vorlage.csv", csvContent);
        }
        function downloadBusTemplate() { /* ... */
             const csvContent = "Bus Kennzeichnung;Sitzplätze\nBus 1 (Müller Reisen);50\nBus 2 (Sonderfahrt);70\n"; downloadFile("busse_vorlage.csv", csvContent);
        }
        function exportGruppenToCSV() { /* ... */
             hideMessage(); const gruppenInputs = document.getElementById('gruppenContainer').children; if (gruppenInputs.length === 0) { showMessage("Keine Gruppen zum Exportieren vorhanden.", 'info'); return; } const csvRows = ['Gruppenname;Teilnehmerzahl']; let validGroupsFound = 0; for (let i = 0; i < gruppenInputs.length; i++) { if (!gruppenInputs[i] || !gruppenInputs[i].id) continue; const idSuffix = gruppenInputs[i].id.substring('gruppe-'.length); const nameInput = document.getElementById(`gruppeName-${idSuffix}`); const sizeInput = document.getElementById(`gruppeSize-${idSuffix}`); if (!nameInput || !sizeInput) continue; const name = nameInput.value.trim(); const size = sizeInput.value.trim(); if (name && size && parseInt(size) > 0) { const safeName = `"${name.replace(/"/g, '""')}"`; csvRows.push(`${safeName};${size}`); validGroupsFound++; } } if (validGroupsFound > 0) { downloadFile("gruppen_export.csv", csvRows.join('\n')); showMessage("Gruppen erfolgreich exportiert.", "success"); } else { showMessage("Keine gültigen Gruppen zum Exportieren gefunden.", 'warning'); }
        }
        function exportBusseToCSV() { /* ... */
              hideMessage(); const busInputs = document.getElementById('busContainer').children; if (busInputs.length === 0) { showMessage("Keine Busse zum Exportieren vorhanden.", 'info'); return; } const csvRows = ['Bus Kennzeichnung;Sitzplätze']; let validBusesFound = 0; for (let i = 0; i < busInputs.length; i++) { if (!busInputs[i] || !busInputs[i].id) continue; const idSuffix = busInputs[i].id.substring('bus-'.length); const nameInput = document.getElementById(`busName-${idSuffix}`); const capacityInput = document.getElementById(`busCapacity-${idSuffix}`); if (!nameInput || !capacityInput) continue; const name = nameInput.value.trim(); const capacity = capacityInput.value.trim(); if (name && capacity && parseInt(capacity) > 0) { const safeName = `"${name.replace(/"/g, '""')}"`; csvRows.push(`${safeName};${capacity}`); validBusesFound++; } } if (validBusesFound > 0) { downloadFile("busse_export.csv", csvRows.join('\n')); showMessage("Busse erfolgreich exportiert.", "success"); } else { showMessage("Keine gültigen Busse zum Exportieren gefunden.", 'warning'); }
        }

        // --- Hilfsfunktion: Array mischen (Fisher-Yates) ---
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        // --- Kernfunktion zur Zuteilung (Intern) ---
        function runAllocationAttempt(gruppenData, busData, buffer) {
            // Phase 1: Zuweisung ganzer Gruppen
            for (const gruppe of gruppenData) {
                if (gruppe.remainingSize === gruppe.size && !gruppe.assigned) {
                    for (const bus of busData) {
                        const effectiveCapacity = bus.capacity - buffer;
                        if (effectiveCapacity - bus.currentLoad >= gruppe.size) {
                            bus.assignedParts.push({ groupName: gruppe.name, groupSize: gruppe.size, assignedSize: gruppe.size });
                            bus.currentLoad += gruppe.size;
                            gruppe.assigned = true; gruppe.remainingSize = 0; gruppe.assignedToBuses.push(bus.id);
                            break;
                        }
                    }
                }
            }
            // Phase 2: Aufteilen
            const unassignedGroups = gruppenData.filter(g => !g.assigned || g.remainingSize > 0);
            for (const gruppe of unassignedGroups) {
                if (gruppe.remainingSize <= 0) continue;
                for (const bus of busData) {
                    if (gruppe.remainingSize <= 0) break;
                    if (gruppe.assignedToBuses.length >= 2 && !gruppe.assignedToBuses.includes(bus.id)) { continue; }
                    const effectiveRemainingCapacity = Math.max(0, (bus.capacity - buffer) - bus.currentLoad);
                    if (effectiveRemainingCapacity > 0) {
                        const amountToAssign = Math.min(gruppe.remainingSize, effectiveRemainingCapacity);
                        if (amountToAssign > 0) {
                            bus.assignedParts.push({ groupName: gruppe.name, groupSize: gruppe.size, assignedSize: amountToAssign });
                            bus.currentLoad += amountToAssign;
                            gruppe.remainingSize -= amountToAssign;
                            gruppe.assigned = true;
                            if(gruppe.remainingSize < gruppe.size) gruppe.isSplit = true;
                            if (!gruppe.assignedToBuses.includes(bus.id)) { gruppe.assignedToBuses.push(bus.id); }
                        }
                    }
                }
            }
            const unassignedCount = gruppenData.reduce((sum, g) => sum + g.remainingSize, 0);
            return { busse: busData, gruppen: gruppenData, unassignedCount: unassignedCount };
        }

        // --- Hauptfunktion zur Berechnung der Zuteilung (mit Retry) ---
        function calculateAssignment() {
            hideMessage();

            // 0. UI zurücksetzen
            const outputContainer = document.getElementById('ergebnisOutput');
            const aufgeteiltDetailsContainer = document.getElementById('aufgeteiltDetailsOutput');
            const nichtZugeordnetContainer = document.getElementById('nichtZugeordnetOutput');
            const erfolgContainer = document.getElementById('erfolgMeldungOutput');
            const zusammenfassungContainer = document.getElementById('zusammenfassungBereich');
            const ergebnisTitel = document.getElementById('ergebnisTitel');
            const actionButtonsContainer = document.getElementById('actionButtonsContainer');
            const manualAdjustContainer = document.getElementById('manualAdjustContainer');
            outputContainer.innerHTML = ''; aufgeteiltDetailsContainer.innerHTML = ''; nichtZugeordnetContainer.innerHTML = ''; erfolgContainer.innerHTML = ''; zusammenfassungContainer.innerHTML = '';
            ergebnisTitel.style.display = 'none'; actionButtonsContainer.style.display = 'none'; manualAdjustContainer.style.display = 'none';
            window.latestBusData = null; window.latestGroupData = null; window.latestSummaryData = null;

            // 1. Originaldaten einlesen und validieren
            const buffer = parseInt(document.getElementById('reservedSeats').value) || 0;
            if (buffer < 0) { showMessage("Der Puffer für freie Plätze darf nicht negativ sein.", 'error'); return; }
            const originalGruppen = []; const originalBusse = []; let inputError = false;
            // Gruppen einlesen
            const gruppenInputs = document.getElementById('gruppenContainer').children;
            for (let i = 0; i < gruppenInputs.length; i++) { /* ... Validierung ... */
                if (!gruppenInputs[i] || !gruppenInputs[i].id) continue; const idSuffix = gruppenInputs[i].id.substring('gruppe-'.length); const nameInput = document.getElementById(`gruppeName-${idSuffix}`); const sizeInput = document.getElementById(`gruppeSize-${idSuffix}`); if (!nameInput || !sizeInput) continue; const name = nameInput.value.trim(); const size = parseInt(sizeInput.value); if (name && !isNaN(size) && size > 0) { originalGruppen.push({ id: gruppenInputs[i].id, name: name, size: size }); } else if (name || (!isNaN(size) && size > 0)) { showMessage(`FEHLER: Bitte gültigen Namen und Teilnehmerzahl > 0 für Gruppe "${name || 'Unbenannt'}" (Zeile ${i+1}) eingeben.`, 'error'); inputError = true; if (!name) nameInput.focus(); else sizeInput.focus(); return; }
            }
            // Busse einlesen
            const busInputs = document.getElementById('busContainer').children;
            for (let i = 0; i < busInputs.length; i++) { /* ... Validierung ... */
                 if (!busInputs[i] || !busInputs[i].id) continue; const idSuffix = busInputs[i].id.substring('bus-'.length); const nameInput = document.getElementById(`busName-${idSuffix}`); const capacityInput = document.getElementById(`busCapacity-${idSuffix}`); if (!nameInput || !capacityInput) continue; const name = nameInput.value.trim(); const capacity = parseInt(capacityInput.value); if (name && !isNaN(capacity) && capacity > 0) { originalBusse.push({ id: busInputs[i].id, name: name, capacity: capacity }); } else if (name || (!isNaN(capacity) && capacity > 0)) { showMessage(`FEHLER: Bitte gültige Kennzeichnung und Kapazität > 0 für Bus "${name || 'Unbenannt'}" (Zeile ${i+1}) eingeben.`, 'error'); inputError = true; if (!name) nameInput.focus(); else capacityInput.focus(); return; }
            }
            if (originalGruppen.length === 0 || originalBusse.length === 0) { showMessage("Bitte mindestens eine Gruppe und einen Bus hinzufügen.", 'info'); return; }

            // 2. Gesamtzahlen berechnen & Zusammenfassung anzeigen
            let gesamtTeilnehmer = originalGruppen.reduce((sum, g) => sum + g.size, 0); let gesamtPlaetze = originalBusse.reduce((sum, b) => sum + b.capacity, 0); let effektiveGesamtPlaetze = originalBusse.reduce((sum, b) => sum + Math.max(0, b.capacity - buffer), 0);
            const summaryDiv = document.createElement('div'); let summaryMessage = `<p>Gesamte Teilnehmerzahl: <strong>${gesamtTeilnehmer}</strong></p><p>Gesamte Busplätze: <strong>${gesamtPlaetze}</strong></p><p>Freizuhaltender Puffer pro Bus: <strong>${buffer}</strong></p><p>Effektiv verfügbare Plätze (nach Puffer): <strong>${effektiveGesamtPlaetze}</strong></p>`;
            let isOk = effektiveGesamtPlaetze >= gesamtTeilnehmer; const summaryBaseClass = 'summary-box'; const summaryOkClass = 'summary-ok'; const summaryWarnClass = 'summary-warning';
            if (isOk) { summaryDiv.className = `${summaryBaseClass} ${summaryOkClass}`; summaryMessage += `<p><strong>Genügend effektive Plätze vorhanden.</strong></p>`; } else { summaryDiv.className = `${summaryBaseClass} ${summaryWarnClass}`; summaryMessage += `<p><strong>Warnung: ${gesamtTeilnehmer - effektiveGesamtPlaetze} Plätze fehlen (nach Abzug des Puffers)!</strong></p>`; }
            summaryDiv.innerHTML = summaryMessage; zusammenfassungContainer.appendChild(summaryDiv);
            window.latestSummaryData = { gesamtTeilnehmer, gesamtPlaetze, buffer, effektiveGesamtPlaetze, isOk };

            // --- Zuteilungsversuche ---
            let bestResult = null; let attemptCounter = 0; let success = false; let usedRetries = false;
            function prepareAttemptData(gruppenSource, busSource) { let gruppenCopy = JSON.parse(JSON.stringify(gruppenSource)); let busCopy = JSON.parse(JSON.stringify(busSource)); gruppenCopy.forEach(g => { g.assigned = false; g.remainingSize = g.size; g.isSplit = false; g.assignedToBuses = []; }); busCopy.forEach(b => { b.currentLoad = 0; b.assignedParts = []; }); return { gruppenCopy, busCopy }; }

            // 3. Initialer Versuch (FFD)
            attemptCounter++; console.log(`Starte Versuch ${attemptCounter} (Initial FFD)`);
            let initialAttemptData = prepareAttemptData(originalGruppen, originalBusse);
            initialAttemptData.gruppenCopy.sort((a, b) => b.size - a.size); // Sortieren
            bestResult = runAllocationAttempt(initialAttemptData.gruppenCopy, initialAttemptData.busCopy, buffer);
            console.log(`Versuch ${attemptCounter} beendet. Nicht zugewiesen: ${bestResult.unassignedCount}`);

            // 4. Retry-Versuche
            if (bestResult.unassignedCount > 0) {
                console.log(`Initialer Versuch fehlgeschlagen. Starte bis zu ${MAX_RETRIES} Retries mit gemischten Bussen.`);
                usedRetries = true;
                for (let i = 0; i < MAX_RETRIES; i++) {
                    attemptCounter++; console.log(`Starte Versuch ${attemptCounter} (Retry ${i + 1})`);
                    let retryData = prepareAttemptData(originalGruppen, originalBusse);
                    shuffleArray(retryData.busCopy); // Busse mischen
                    retryData.gruppenCopy.sort((a, b) => b.size - a.size); // Gruppen sortieren
                    let currentResult = runAllocationAttempt(retryData.gruppenCopy, retryData.busCopy, buffer);
                    console.log(`Versuch ${attemptCounter} beendet. Nicht zugewiesen: ${currentResult.unassignedCount}`);
                    if (currentResult.unassignedCount === 0) { bestResult = currentResult; success = true; console.log(`Erfolg in Versuch ${attemptCounter}!`); break; }
                    if (currentResult.unassignedCount < bestResult.unassignedCount) { bestResult = currentResult; console.log(`Versuch ${attemptCounter} ist bisher das beste Ergebnis.`); }
                }
            } else { success = true; console.log("Initialer Versuch war erfolgreich."); }

            // 5. Finales Ergebnis speichern und anzeigen
            window.latestBusData = bestResult.busse;
            window.latestGroupData = bestResult.gruppen;

            // *** NEU: Busdaten alphabetisch sortieren ***
            if (window.latestBusData) {
                window.latestBusData.sort((a, b) => a.name.localeCompare(b.name, 'de', { sensitivity: 'base' }));
                console.log("Finale Busdaten alphabetisch sortiert.");
            }

             if (success) { if (usedRetries) { showMessage(`Zuteilung erfolgreich nach ${attemptCounter-1} Wiederholungsversuch(en)! 🎉`, 'success'); } else { showMessage("Zuteilung erfolgreich im ersten Versuch! 🎉", 'success'); } }
             else { showMessage(`Zuteilung konnte nicht alle Teilnehmer (${bestResult.unassignedCount} übrig) zuweisen, auch nach ${MAX_RETRIES} zufälligen Versuchen. Bestes gefundenes Ergebnis wird angezeigt.`, 'warning'); }
            ergebnisTitel.style.display = 'block'; actionButtonsContainer.style.display = 'flex';
            displayResultsWithSplitting(window.latestBusData, window.latestGroupData); // Verwendet jetzt die sortierten Busdaten
            populateManualMoveUI(); // Verwendet jetzt die sortierten Busdaten für die Dropdowns
        }

        // --- Funktion zur Anzeige der Ergebnisse (unverändert, nutzt sortierte Daten) ---
        function displayResultsWithSplitting(busse, alleGruppen) { /* ... */
            const outputContainer = document.getElementById('ergebnisOutput'); const aufgeteiltDetailsContainer = document.getElementById('aufgeteiltDetailsOutput'); const nichtZugeordnetContainer = document.getElementById('nichtZugeordnetOutput'); const erfolgContainer = document.getElementById('erfolgMeldungOutput');
            outputContainer.innerHTML = ''; aufgeteiltDetailsContainer.innerHTML = ''; nichtZugeordnetContainer.innerHTML = ''; erfolgContainer.innerHTML = '';
            busse.forEach(bus => { const busDiv = document.createElement('div'); busDiv.classList.add('result-box'); let gruppenListeHtml = '<ul>'; if (bus.assignedParts.length > 0) { bus.assignedParts.forEach(part => { if (part.assignedSize === part.groupSize) { gruppenListeHtml += `<li>${part.groupName} (${part.assignedSize} P.)</li>`; } else { gruppenListeHtml += `<li class="split-part">${part.groupName} (Teil: ${part.assignedSize} / ${part.groupSize} P.)</li>`; } }); } else { gruppenListeHtml += '<li>Keine Gruppen zugewiesen</li>'; } gruppenListeHtml += '</ul>'; busDiv.innerHTML = `<h4>${bus.name}</h4>${gruppenListeHtml}<p>Belegt: ${bus.currentLoad} / ${bus.capacity}</p><p>Frei: ${bus.capacity - bus.currentLoad}</p>`; outputContainer.appendChild(busDiv); });
            const splitGroupsDetails = {}; alleGruppen.filter(g => g.isSplit).forEach(gruppe => { if (!splitGroupsDetails[gruppe.name]) { splitGroupsDetails[gruppe.name] = { totalSize: gruppe.size, parts: [] }; } }); busse.forEach(bus => { bus.assignedParts.forEach(part => { if (part.assignedSize < part.groupSize && splitGroupsDetails[part.groupName]) { splitGroupsDetails[part.groupName].parts.push({ busName: bus.name, assignedSize: part.assignedSize }); } }); });
            if (Object.keys(splitGroupsDetails).length > 0) { const detailsDiv = document.createElement('div'); detailsDiv.classList.add('result-box', 'split-details-box', 'md:col-span-2', 'lg:col-span-3'); let detailsHtml = '<h4>Aufgeteilte Gruppen (Details)</h4><ul>'; for (const groupName in splitGroupsDetails) { const details = splitGroupsDetails[groupName]; let assignedTotal = 0; detailsHtml += `<li><strong>${groupName} (Gesamt: ${details.totalSize} P.)</strong><ul>`; details.parts.forEach(p => { detailsHtml += `<li>${p.assignedSize} P. in ${p.busName}</li>`; assignedTotal += p.assignedSize; }); const currentGroupState = alleGruppen.find(g => g.name === groupName); const remaining = currentGroupState ? currentGroupState.remainingSize : (details.totalSize - assignedTotal); if (remaining > 0) { detailsHtml += `<li style="color: #B91C1C; font-weight: bold;">${remaining} P. nicht zugewiesen</li>`; } detailsHtml += '</ul></li>'; } detailsHtml += '</ul>'; detailsDiv.innerHTML = detailsHtml; aufgeteiltDetailsContainer.appendChild(detailsDiv); }
            const totalUnassigned = alleGruppen.reduce((sum, g) => sum + g.remainingSize, 0); const unassignedList = alleGruppen.filter(g => g.remainingSize > 0);
            if (totalUnassigned > 0) { const unassignedDiv = document.createElement('div'); unassignedDiv.classList.add('result-box', 'unassigned-box', 'md:col-span-2', 'lg:col-span-3'); let unassignedListHtml = '<ul>'; unassignedList.forEach(g => { unassignedListHtml += `<li>${g.name} (${g.remainingSize} P. nicht zugewiesen)</li>`; }); unassignedListHtml += '</ul>'; unassignedDiv.innerHTML = `<h4>Nicht zugewiesene Plätze (${totalUnassigned} Gesamt)</h4>${unassignedListHtml}<p>Für diese Gruppen/Teilnehmer konnten keine freien Plätze mehr gefunden werden.</p>`; nichtZugeordnetContainer.appendChild(unassignedDiv); }
             if (totalUnassigned === 0 && alleGruppen.length > 0 && document.querySelector('.message-success')) { const successDiv = document.createElement('div'); successDiv.classList.add('p-4', 'bg-green-100', 'text-green-800', 'rounded-lg', 'md:col-span-2', 'lg:col-span-3', 'text-center', 'font-medium'); successDiv.textContent = 'Alle Gruppen vollständig zugewiesen!'; erfolgContainer.appendChild(successDiv); }
        }

        // --- Funktionen für manuelle Anpassung (unverändert, nutzt sortierte Daten) ---
        function toggleManualAdjustUI() { /* ... */
             const container = document.getElementById('manualAdjustContainer'); if (!window.latestBusData) { showMessage("Bitte berechnen Sie zuerst die Zuteilung.", 'warning'); return; } if (container.style.display === 'none') { populateManualMoveUI(); updateManualAdjustUI(); container.style.display = 'block'; container.scrollIntoView({ behavior: 'smooth', block: 'center' }); } else { container.style.display = 'none'; } hideMessage();
        }
        function updateManualAdjustUI() { /* ... */
             const mode = document.querySelector('input[name="manualAdjustMode"]:checked').value; const group1Container = document.getElementById('group1SelectContainer'); const group2Container = document.getElementById('group2SelectContainer'); const targetBusContainer = document.getElementById('targetBusSelectContainer'); const actionButton = document.getElementById('manualAdjustButton'); group1Container.style.display = 'block'; if (mode === 'move') { group2Container.style.display = 'none'; targetBusContainer.style.display = 'block'; actionButton.textContent = 'Gruppe verschieben'; group1Container.querySelector('label').textContent = 'Gruppe zum Verschieben:'; } else { group2Container.style.display = 'block'; targetBusContainer.style.display = 'none'; actionButton.textContent = 'Gruppen tauschen'; group1Container.querySelector('label').textContent = 'Gruppe 1:'; group2Container.querySelector('label').textContent = 'Gruppe 2:'; }
        }
        function populateManualMoveUI() { /* ... */
             const groupSelect1 = document.getElementById('groupToMoveSelect'); const groupSelect2 = document.getElementById('groupToSwapSelect'); const busSelect = document.getElementById('targetBusSelect'); groupSelect1.innerHTML = '<option value="">-- Gruppe 1 wählen --</option>'; groupSelect2.innerHTML = '<option value="">-- Gruppe 2 wählen --</option>'; busSelect.innerHTML = '<option value="">-- Ziel-Bus wählen --</option>'; if (!window.latestBusData || !window.latestGroupData) return; const assignedWholeGroupsMap = new Map(); window.latestBusData.forEach(bus => { bus.assignedParts.forEach((part) => { if (part.assignedSize === part.groupSize) { const uniqueKey = `${part.groupName}@@${part.groupSize}@@${bus.id}`; if (!assignedWholeGroupsMap.has(uniqueKey)) { assignedWholeGroupsMap.set(uniqueKey, { name: part.groupName, size: part.groupSize, currentBusId: bus.id, currentBusName: bus.name }); } } }); }); const sortedGroupList = Array.from(assignedWholeGroupsMap.values()).sort((a, b) => a.name.localeCompare(b.name, 'de', { sensitivity: 'base' })); sortedGroupList.forEach(groupInfo => { const uniqueKey = `${groupInfo.name}@@${groupInfo.size}@@${groupInfo.currentBusId}`; const optionText = `${groupInfo.name} (${groupInfo.size} P.) - in ${groupInfo.currentBusName}`; const option1 = document.createElement('option'); option1.value = uniqueKey; option1.textContent = optionText; groupSelect1.appendChild(option1); const option2 = option1.cloneNode(true); groupSelect2.appendChild(option2); });
             // Bus-Dropdown wird jetzt auch mit sortierten Bussen gefüllt
             window.latestBusData.forEach(bus => { const option = document.createElement('option'); option.value = bus.id; option.textContent = `${bus.name} (Frei: ${bus.capacity - bus.currentLoad})`; busSelect.appendChild(option); });
        }
        function handleManualAdjustment() { /* ... */
              hideMessage(); const mode = document.querySelector('input[name="manualAdjustMode"]:checked').value; if (mode === 'move') { manualMoveGroup(); } else { manualSwapGroups(); }
        }
        function manualMoveGroup() { /* ... */
            const groupSelect = document.getElementById('groupToMoveSelect'); const targetBusSelect = document.getElementById('targetBusSelect'); const selectedGroupOption = groupSelect.options[groupSelect.selectedIndex]; const targetBusId = targetBusSelect.value; if (!selectedGroupOption || !selectedGroupOption.value || !targetBusId) { showMessage("Bitte wählen Sie eine Gruppe und einen Ziel-Bus aus.", 'warning'); return; } const uniqueKey = selectedGroupOption.value; const [groupName, groupSizeStr, currentBusId] = uniqueKey.split('@@'); const groupSize = parseInt(groupSizeStr); if (currentBusId === targetBusId) { showMessage("Die Gruppe befindet sich bereits in diesem Bus.", 'info'); return; } const sourceBus = window.latestBusData.find(b => b.id === currentBusId); const targetBus = window.latestBusData.find(b => b.id === targetBusId); if (!sourceBus || !targetBus) { showMessage("Fehler: Quell- oder Zielbus nicht gefunden.", 'error'); console.error("Source/Target bus not found", { currentBusId, targetBusId }); return; } const buffer = window.latestSummaryData.buffer; const targetEffectiveCapacity = targetBus.capacity - buffer; const availableSpaceInTarget = Math.max(0, targetEffectiveCapacity - targetBus.currentLoad); if (availableSpaceInTarget < groupSize) { showMessage(`Fehler: Nicht genügend Platz im Ziel-Bus "${targetBus.name}". Benötigt: ${groupSize}, Verfügbar (nach Puffer): ${availableSpaceInTarget}`, 'error'); return; } const groupIndexInSource = sourceBus.assignedParts.findIndex(part => part.groupName === groupName && part.assignedSize === groupSize); if (groupIndexInSource === -1) { showMessage(`Fehler: Gruppe "${groupName}" nicht als ganze Gruppe im Quellbus "${sourceBus.name}" gefunden.`, 'error'); console.error("Group not found in source bus parts", { groupName, groupSize, sourceBus }); return; } const [movedGroupData] = sourceBus.assignedParts.splice(groupIndexInSource, 1); sourceBus.currentLoad -= groupSize; targetBus.assignedParts.push(movedGroupData); targetBus.currentLoad += groupSize;
            // Wichtig: Nach manueller Anpassung Busdaten neu sortieren!
            window.latestBusData.sort((a, b) => a.name.localeCompare(b.name, 'de', { sensitivity: 'base' }));
            displayResultsWithSplitting(window.latestBusData, window.latestGroupData); populateManualMoveUI(); showMessage(`Gruppe "${groupName}" erfolgreich von Bus "${sourceBus.name}" nach Bus "${targetBus.name}" verschoben.`, 'success');
        }
        function manualSwapGroups() { /* ... */
             const groupSelect1 = document.getElementById('groupToMoveSelect'); const groupSelect2 = document.getElementById('groupToSwapSelect'); const selectedGroup1Option = groupSelect1.options[groupSelect1.selectedIndex]; const selectedGroup2Option = groupSelect2.options[groupSelect2.selectedIndex]; if (!selectedGroup1Option || !selectedGroup1Option.value || !selectedGroup2Option || !selectedGroup2Option.value) { showMessage("Bitte wählen Sie zwei Gruppen zum Tauschen aus.", 'warning'); return; } const uniqueKey1 = selectedGroup1Option.value; const uniqueKey2 = selectedGroup2Option.value; if (uniqueKey1 === uniqueKey2) { showMessage("Bitte wählen Sie zwei unterschiedliche Gruppen zum Tauschen aus.", 'warning'); return; } const [group1Name, group1SizeStr, group1BusId] = uniqueKey1.split('@@'); const [group2Name, group2SizeStr, group2BusId] = uniqueKey2.split('@@'); const group1Size = parseInt(group1SizeStr); const group2Size = parseInt(group2SizeStr); const bus1 = window.latestBusData.find(b => b.id === group1BusId); const bus2 = window.latestBusData.find(b => b.id === group2BusId); if (!bus1 || !bus2) { showMessage("Fehler: Einer der Busse der Gruppen nicht gefunden.", 'error'); console.error("One or both buses for swap not found", { group1BusId, group2BusId }); return; } const buffer = window.latestSummaryData.buffer; const bus2EffectiveCapacity = bus2.capacity - buffer; const spaceInBus2AfterRemovingG2 = Math.max(0, bus2EffectiveCapacity - (bus2.currentLoad - group2Size)); if (spaceInBus2AfterRemovingG2 < group1Size) { showMessage(`Fehler: Gruppe "${group1Name}" (${group1Size} P.) passt nicht in Bus "${bus2.name}" (Verfügbar nach Puffer: ${spaceInBus2AfterRemovingG2})`, 'error'); return; } const bus1EffectiveCapacity = bus1.capacity - buffer; const spaceInBus1AfterRemovingG1 = Math.max(0, bus1EffectiveCapacity - (bus1.currentLoad - group1Size)); if (spaceInBus1AfterRemovingG1 < group2Size) { showMessage(`Fehler: Gruppe "${group2Name}" (${group2Size} P.) passt nicht in Bus "${bus1.name}" (Verfügbar nach Puffer: ${spaceInBus1AfterRemovingG1})`, 'error'); return; } const group1Index = bus1.assignedParts.findIndex(part => part.groupName === group1Name && part.assignedSize === group1Size); const group2Index = bus2.assignedParts.findIndex(part => part.groupName === group2Name && part.assignedSize === group2Size); if (group1Index === -1 || group2Index === -1) { showMessage("Fehler: Eine der Gruppen konnte im Bus nicht gefunden werden.", 'error'); console.error("Group index not found for swap", { group1Index, group2Index }); return; } const [group1Data] = bus1.assignedParts.splice(group1Index, 1); bus1.currentLoad -= group1Size; const [group2Data] = bus2.assignedParts.splice(group2Index, 1); bus2.currentLoad -= group2Size; bus1.assignedParts.push(group2Data); bus1.currentLoad += group2Size; bus2.assignedParts.push(group1Data); bus2.currentLoad += group1Size;
             // Wichtig: Nach manueller Anpassung Busdaten neu sortieren!
             window.latestBusData.sort((a, b) => a.name.localeCompare(b.name, 'de', { sensitivity: 'base' }));
             displayResultsWithSplitting(window.latestBusData, window.latestGroupData); populateManualMoveUI(); showMessage(`Gruppen "${group1Name}" und "${group2Name}" erfolgreich getauscht.`, 'success');
        }

        // --- Funktion zum PDF-Download (unverändert, nutzt sortierte Daten) ---
        function downloadResultsAsPDF() { /* ... */
            hideMessage(); if (!window.latestBusData || !window.latestSummaryData) { showMessage("Bitte berechnen Sie zuerst die Zuteilung.", 'warning'); return; }
            try {
                const { jsPDF } = window.jspdf; const doc = new jsPDF('p', 'mm', 'a4'); doc.setFont('helvetica', 'normal');
                const pageMargin = 15; const pageHeight = doc.internal.pageSize.getHeight(); const pageWidth = doc.internal.pageSize.getWidth(); let currentY = pageMargin;
                doc.setFontSize(16); doc.text("Zusammenfassung der Buszuteilung", pageWidth / 2, currentY, { align: 'center' }); currentY += 15; doc.setFontSize(11);
                doc.text(`Gesamte Teilnehmerzahl:`, pageMargin, currentY); doc.text(`${window.latestSummaryData.gesamtTeilnehmer}`, pageWidth - pageMargin, currentY, { align: 'right' }); currentY += 6; doc.text(`Gesamte Busplätze:`, pageMargin, currentY); doc.text(`${window.latestSummaryData.gesamtPlaetze}`, pageWidth - pageMargin, currentY, { align: 'right' }); currentY += 6; doc.text(`Freizuhaltender Puffer pro Bus:`, pageMargin, currentY); doc.text(`${window.latestSummaryData.buffer}`, pageWidth - pageMargin, currentY, { align: 'right' }); currentY += 6; doc.text(`Effektiv verfügbare Plätze:`, pageMargin, currentY); doc.text(`${window.latestSummaryData.effektiveGesamtPlaetze}`, pageWidth - pageMargin, currentY, { align: 'right' }); currentY += 8;
                if (window.latestSummaryData.isOk) { doc.setTextColor(0, 100, 0); doc.text("Genügend effektive Plätze vorhanden.", pageMargin, currentY); } else { doc.setTextColor(255, 0, 0); doc.text(`Warnung: ${window.latestSummaryData.gesamtTeilnehmer - window.latestSummaryData.effektiveGesamtPlaetze} Plätze fehlen!`, pageMargin, currentY); }
                doc.setTextColor(0, 0, 0); currentY += 10; doc.setFontSize(12); doc.text("Busübersicht mit Gruppen:", pageMargin, currentY); currentY += 6;
                const summaryTableData = []; window.latestBusData.forEach(bus => { let groupsString = bus.assignedParts.map(part => { if (part.assignedSize === part.groupSize) { return `${part.groupName} (${part.assignedSize} P.)`; } else { return `${part.groupName} (Teil: ${part.assignedSize}/${part.groupSize} P.)`; } }).join('\n'); if (!groupsString) { groupsString = "- Keine -"; } summaryTableData.push([bus.name, groupsString]); });
                doc.autoTable({ head: [['Bus', 'Zugewiesene Gruppen']], body: summaryTableData, startY: currentY, theme: 'grid', headStyles: { fillColor: [220, 220, 220], textColor: 40, fontStyle: 'bold', fontSize: 10 }, margin: { left: pageMargin, right: pageMargin }, styles: { font: 'helvetica', fontSize: 9, cellPadding: 2, overflow: 'linebreak' }, columnStyles: { 0: { cellWidth: 60 }, 1: { cellWidth: 'auto'} }, didDrawPage: function(data) { currentY = pageMargin; } }); currentY = doc.autoTable.previous.finalY + 10;
                if (window.latestBusData.length > 0) { doc.addPage(); } window.latestBusData.forEach((bus, index) => { if (index > 0) { doc.addPage(); } currentY = pageMargin; doc.setFontSize(96); const textHeight = doc.getTextDimensions(bus.name, { fontSize: 96 }).h; const textYDetail = pageMargin + textHeight + 20; doc.text(bus.name, pageWidth / 2, textYDetail, { align: 'center' }); currentY = textYDetail + 25; doc.setFontSize(11); doc.text(`Kapazität: ${bus.capacity} Plätze`, pageMargin, currentY); doc.text(`Belegt: ${bus.currentLoad} Plätze`, pageMargin + 60, currentY); doc.text(`Frei: ${bus.capacity - bus.currentLoad} Plätze`, pageMargin + 110, currentY); currentY += 15; const tableDataDetail = []; bus.assignedParts.forEach(part => { let teilnehmerText = ""; if (part.assignedSize === part.groupSize) { teilnehmerText = `${part.assignedSize} P.`; } else { teilnehmerText = `Teil: ${part.assignedSize} / ${part.groupSize} P.`; } tableDataDetail.push([String(part.groupName), String(teilnehmerText)]); }); if (tableDataDetail.length > 0) { doc.autoTable({ head: [['Gruppe', 'Teilnehmer']], body: tableDataDetail, startY: currentY, theme: 'grid', headStyles: { fillColor: [220, 220, 220], textColor: 40, fontStyle: 'bold' }, margin: { left: pageMargin, right: pageMargin }, styles: { font: 'helvetica', fontSize: 10, cellPadding: 2 }, didDrawPage: function (data) { currentY = data.cursor.y + 5; } }); } else { doc.text("Keine Gruppen diesem Bus zugewiesen.", pageMargin, currentY); } const pageCount = doc.internal.getNumberOfPages(); doc.setFontSize(9); doc.text(`Seite ${doc.internal.getCurrentPageInfo().pageNumber} von ${pageCount}`, pageWidth - pageMargin, pageHeight - 10, { align: 'right' }); });
                doc.save('buszuteilung_ergebnis.pdf'); showMessage("PDF wird generiert und heruntergeladen...", 'success');
            } catch (error) { console.error("Fehler beim Erstellen des PDFs:", error); showMessage(`Fehler beim Erstellen des PDFs: ${error.message}`, 'error'); }
        }

        // --- Initialisierung (unverändert) ---
        window.onload = () => { /* ... */ };

    </script>

</body>
</html>

